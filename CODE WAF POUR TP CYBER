 

package main 

import ( "bytes" "io" "log" "net/http" "net/http/httputil" "net/url" "regexp" "strings" ) 

var dangerousPatterns = []*regexp.Regexp{ regexp.MustCompile((?i)(union.*select|select.*from)), regexp.MustCompile((?i)(\%27)|(\')|(\-\-)|(\%23)|(#)), regexp.MustCompile((?i)(<script|javascript:|onerror=|onload=)), regexp.MustCompile((?i)(\.\.\/|\.\.\\|%2e%2e%2f|%2e%2e%5c|%252e%252e%252f)), regexp.MustCompile((?i)(exec|execute|eval|system)), regexp.MustCompile("quantity"\s*:\s*-\d+), } 

func wafMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { path := r.URL.Path query := r.URL.RawQuery fullURL := r.URL.String() 

  // RÈGLE 1 : Anti-Directory Listing 
   if strings.HasSuffix(path, "/") &       !strings.Contains(path, "api") && 
      path != "/" && 
      !strings.Contains(path, "socket.io") { 
       log.Printf("[BLOCKED] %s %s%s - Directory listing attempt", r.Method, r.Host, r.URL) 
       http.Error(w, "403 Forbidden - Directory listing blocked by WAF", http.StatusForbidden) 
       return 
   } 
 
   // RÈGLE 2 : Bloquer les fichiers sensibles 
   sensitivePaths := []string{".map", ".bak", ".old", ".backup", "package.json"} 
   for _, sensitive := range sensitivePaths { 
       if strings.Contains(strings.ToLower(path), sensitive) { 
           log.Printf("[BLOCKED] %s %s%s - Sensitive file access attempt", r.Method, r.Host, r.URL) 
           http.Error(w, "403 Forbidden - Access to sensitive files blocked by WAF", http.StatusForbidden) 
           return 
       } 
   } 
 
   // Décoder l'URL 
   decodedPath, _ := url.QueryUnescape(path) 
   decodedQuery, _ := url.QueryUnescape(query) 
   decodedFull := decodedPath + "?" + decodedQuery 
 
   // Liste des données à vérifier 
   dataToCheck := []string{query, path, fullURL, decodedPath, decodedQuery, decodedFull} 
 
   // RÈGLE 3 : Lire le body pour POST/PUT/PATCH et vérifier quantity 
   var bodyBytes []byte 
   if r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH" { 
       bodyBytes, _ = io.ReadAll(r.Body) 
       r.Body.Close() 
       r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes)) 
       dataToCheck = append(dataToCheck, string(bodyBytes)) 
   } 
 
   // VÉRIFIER TOUS LES PATTERNS (y compris quantity négative) 
   for _, data := range dataToCheck { 
       for _, pattern := range dangerousPatterns { 
           if pattern.MatchString(data) { 
               logMsg := "[BLOCKED] " + r.Method + " " + r.Host + r.URL.String() 
               if len(bodyBytes) > 0 { 
                   logMsg += " Body: " + string(bodyBytes) 
               } 
               logMsg += " - Suspicious pattern detected" 
               log.Println(logMsg) 
               http.Error(w, "403 Forbidden - Request blocked by WAF", http.StatusForbidden) 
               return 
           } 
       } 
   } 
 
   // Bloquer les paths suspects 
   suspiciousPaths := []string{"etc/passwd", "etc/shadow", "windows/system32"} 
   for _, suspicious := range suspiciousPaths { 
       if strings.Contains(strings.ToLower(path), suspicious) || 
          strings.Contains(strings.ToLower(decodedPath), suspicious) { 
           log.Printf("[BLOCKED] %s %s%s - Suspicious path detected", r.Method, r.Host, r.URL) 
           http.Error(w, "403 Forbidden - Request blocked by WAF", http.StatusForbidden) 
           return 
       } 
   } 
 
   log.Printf("[ALLOWED] %s %s%s", r.Method, r.Host, r.URL) 
   next.ServeHTTP(w, r) 
}) 
 

} 

func main() { backendURL, _ := url.Parse("http://192.168.1.40:3000") proxy := httputil.NewSingleHostReverseProxy(backendURL) 

http.Handle("/", wafMiddleware(proxy)) 
 
log.Println("WAF + Reverse Proxy running on :80") 
log.Printf("Forwarding to Juice Shop at %s\n", backendURL) 
log.Fatal(http.ListenAndServe(":80", nil)) 
 

} 
